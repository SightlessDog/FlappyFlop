using UnityEngine;
using System;
using GamePlay;
using static GamePlay.CharacterState;
using static Managers.Properties;
using Random = UnityEngine.Random;

public class EnemiesGenerator : MonoBehaviour
{
    [SerializeField] private float sendTimer = 0;
    // Use the same frequency
    [SerializeField] private float frequency = OBSTACLE_FREQUENCY;
    [SerializeField] private int sendBlockTimer = BLOCK_OBSTACLE_FREQUENCY;
    [SerializeField] private bool cheat;
    [SerializeField] private GameObject parent;
    [SerializeField] private CharacterState currentCharacterState;

    public GameObject myEnemy;
    public GameObject myBlockObstacle;
    public GameObject mainCharacter;

    private bool started;
    private float minRange;
    private float maxRange;

    void Awake()
    {
        cheat = false;
        parent = GameObject.FindGameObjectWithTag("AutoGenerated");
        UpdateCurrentCharacterState();
        GameManager.onGameStateChanged += StartGame;
    }

    private void OnDestroy()
    {
        GameManager.onGameStateChanged -= StartGame;
    }

    void StartGame(State state)
    {
        started = state == State.PLAY;
    }

    // Update is called once per frame
    void Update()
    {
        SetGameVar();
        UpdateCurrentCharacterState();
        if (started)
        {
            if (!cheat)
            {
                SendEnemies();
            }
            // Stop sending enemies when the character is dead
            if (mainCharacter != null)
                Time.timeScale = 1;
            else
                Time.timeScale = 0;
        }
    }

    /// <summary>
    /// Send Enemies to the game play
    /// </summary>
    private void SendEnemies()
    {
        sendTimer -= Time.deltaTime;
        //enemies will be sent when the timer reach 0, then reset the timer = frequency
        if (sendTimer <= 0)
        {
            GenerateEnemies();
            sendTimer = frequency;
        }
    }

    private void GenerateEnemies()
    {
        //A block obstacle will be sent when the timer reached 0 to force player to switch to another line
        sendBlockTimer--;
        if (sendBlockTimer == 0)
        {

            switch (currentCharacterState)
            {
                case MIDDLE:
                    CreateEnemies(0);
                    break;
                case LEFT:
                    CreateEnemies(DISTANCE_LEFT);
                    break;
                case RIGHT:
                    CreateEnemies(-DISTANCE_RIGHT);
                    break;
                case DEAD:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            sendBlockTimer = BLOCK_OBSTACLE_FREQUENCY;
        }
    }

    /// <summary>
    /// Toggle Cheat mode
    /// </summary>
    public void ToggleCheatMode()
    {
        cheat = !cheat;
    }
    

    /// <summary>
    /// Create enemies 
    /// </summary>
    private void CreateEnemies(float xPos)
    {
        //yPos will be ENEMY_MID_RANGE
        transform.position = new Vector3(xPos, ENEMY_MID_RANGE, 40);
        Instantiate(myEnemy, transform.position, transform.rotation, parent.transform);
    }

    /// <summary>
    /// Update current State of the character
    /// </summary>
    private void UpdateCurrentCharacterState()
    {
        if (mainCharacter != null)
        {
            currentCharacterState = mainCharacter.GetComponent<CharacterController>().currentState;
        }
    }

    /// <summary>
    /// Set the y position variable for the obstacles
    /// Cheat mode will keep the obstacle static
    /// </summary>
    private void SetGameVar()
    {
        if (cheat)
        {
            minRange = ENEMY_MID_RANGE;
            maxRange = ENEMY_MID_RANGE;
        }
        else
        {
            minRange = ENEMY_MIN_RANGE;
            maxRange = ENEMY_MAX_RANGE;
        }
    }
}
